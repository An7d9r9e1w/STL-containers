------------------------------ I. Subject ---------------------------------------

		*** 1. Tasks ***

1.1	Implement:
	- vector
	- map
	- stack

1.2	Implement:
	- iterators_traits
	- reverse_iterator
	- enable_if
	- is_integral
	- equal/lexicographical compare
	- std::pair
	- std::make_pair


		*** 2. Requirements ***

2.1	Namespace ft

2.2	Stack default container - ft::vector

2.3	Stack is compatible with STL

2.4	Header file name: <container>.hpp
	(i.e. it can begin with a lowercase letter)

		*** 3. Tools ***

3.1	std::allocator

3.2	friend overloads

3.3	std:: (except std::algorithms i guess)

		*** 4. What ??? ***

4.1	Vector<bool> isn't mandatory

		*** 5. Bonus ***

5.1	Set (Black - Red tree)




----------------------------- II. Preparation -----------------------------------

		*** 1. std::allocator ***

1.1 https://en.cppreference.com/w/cpp/memory/allocator
1.2	https://en.cppreference.com/w/cpp/named_req/Allocator
1.3	https://en.cppreference.com/w/cpp/memory/allocator_traits (C++11)

1.4	Wiki:
	https://en.wikipedia.org/wiki/Allocator_(C%2B%2B)

1.5	https://habr.com/ru/post/505632/	- memory allocators

Conclusions:
		Allocator is just class that encapsulates memory allocation/deallocation
	for specified type. Stateless. Needed for abstracting memory model.
		Used by (almost) all STL containers through allocator_traits. (C++11) -> not needed
													----------------


		*** 2. Iterators ***

2.1	std::iterator	[DONE]
	- https://www.cplusplus.com/reference/iterator/
	- https://en.cppreference.com/w/cpp/iterator
	- https://en.cppreference.com/w/cpp/named_req/Iterator

	Iterators can be thought of as an abstraction of pointers.
													 --------

	- https://stackoverflow.com/questions/4688177/how-does-iterator-category-in-c-work

	- Vector has random-access iterator
	- Map has bidirectional iterator
	- Template friend function:
		https://stackoverflow.com/questions/33983366/c-templates-and-friends-linker-error
	- Friend comparison operator:
		https://stackoverflow.com/questions/57927030/is-there-any-reason-to-not-overload-operator-as-member-when-only-comparing-to

2.2	iterators_traits	[DONE]
	- https://en.cppreference.com/w/cpp/iterator/iterator_traits
	- https://www.cplusplus.com/reference/iterator/iterator_traits/

	- Example of using:
		https://rsdn.org/forum/cpp/1997243.all#:~:text=%D1%82%D1%8B%20%D1%82%D0%B0%D0%BA%D0%BE%D0%B9%20%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD-,template,-%3Cclass%20Iterator%3E%0Avoid


2.3	reverse_iterator	[DONE]
	- https://en.cppreference.com/w/cpp/iterator/reverse_iterator
	- https://www.cplusplus.com/reference/iterator/reverse_iterator/

	Base iterator type must be bidirectional or random-access.
							   -------------	-------------

	The reversed version does not point to the same element in the range,
	but to the one preceding it.
		   --------------------



		*** 3. Type traits (C++11) ***

	GNU GCC source:
		https://gcc.gnu.org/onlinedocs/gcc-4.8.0/libstdc++/api/a01609_source.html

3.1	enable_if	[DONE]
	- https://en.cppreference.com/w/cpp/types/enable_if
	- https://www.cplusplus.com/reference/type_traits/enable_if/


3.2	is_integral	[DONE]
	- https://en.cppreference.com/w/cpp/types/is_integral
	- https://www.cplusplus.com/reference/type_traits/is_integral/

	- std::integral_constant:
		https://stackoverflow.com/questions/49205196/whats-the-reason-behind-having-stdintegral-constant
	- std::remove_cv
		https://en.cppreference.com/w/cpp/types/remove_cv
	- Example:
		https://stackoverflow.com/questions/43571962/how-is-stdis-integral-implemented
	- Template specialization
		https://en.cppreference.com/w/cpp/language/partial_specialization
		https://en.cppreference.com/w/cpp/language/template_specialization
		https://stackoverflow.com/questions/38467025/template-specialization-with-empty-brackets-and-struct/38467501
	- Integer types
		https://en.cppreference.com/w/cpp/types/integer

3.3	equal/lexicographical compare
	- Equal:
		https://en.cppreference.com/w/cpp/algorithm/equal
		https://www.cplusplus.com/reference/algorithm/equal/

	- Lexicographical compare
		https://en.cppreference.com/w/cpp/algorithm/lexicographical_compare
		https://www.cplusplus.com/reference/algorithm/lexicographical_compare/



		*** 4. Utility ***

4.1	std::pair	[DONE]
	- https://en.cppreference.com/w/cpp/utility/pair
	- https://www.cplusplus.com/reference/utility/pair/pair/

4.2	std::make_pair	[DONE]
	- https://en.cppreference.com/w/cpp/utility/pair/make_pair
	- https://www.cplusplus.com/reference/utility/make_pair/





---------------------------- III. Mandatory part --------------------------------

	"Working Draft, Standard for Programming Language C++":
		https://eel.is/c++draft/


		*** 1. Vector ***

1.1	Links:
	- https://en.cppreference.com/w/cpp/container/vector
	- https://www.cplusplus.com/reference/vector/vector/

	libstdc++:
		https://gcc.gnu.org/onlinedocs/gcc-4.6.3/libstdc++/api/a01069_source.html


1.2	data() is C++11
	- https://stackoverflow.com/questions/10740094/stdvector-vec-data-or-vec0

1.3 Explicit
	- https://isocpp.org/wiki/faq/cpp11-language-classes#explicit-conversion-operators

1.4	Default vector is NULL

1.5	Allocator:
	- std::allocator<int>().destroy(nullptr)		-	OK
	- std::allocator<int>().deallocate(nullptr, 0)	-	OK

1.6	Adding to pointer is faster than increment (addition && assignment):

	for (size_t i ...)			|		for (...)
		foo(x + i);				|			foo(x++);
	---------------

	BUT:

	for (size_t i ...; ++i)		|		for (size_t y ...; ++y)
		foo(x + i, y + i);		|			foo(x++, y);
										----------------

	BUT:

1.7	Iterator is much slower than simple pointer

	for (size_t i ...; ++i)		|		for (iter it ...; ++it)
		foo(x + i, y + i);		|			foo(x++, *it);
		------------------


1.8	Member access operator []
	- No bounds checking is performed.


1.9	Destructor
	-  Destructs the vector. The destructors of the elements are called and
	the used storage is deallocated. Note, that if the elements are pointers,
	the pointed-to objects are not destroyed.
							   -------------

1.10	Range and fill constructors
	- https://en.cppreference.com/w/cpp/container/vector/vector

		Range constructor has the same effect as
		vector(static_cast<size_type>(first), static_cast<value_type>(last), a)
		if InputIt is an integral type.											(until C++11)

		This overload participates in overload resolution only
		if InputIt satisfies LegacyInputIterator, to avoid ambiguity with		(since C++11)
		explicit vector( size_type count,
                 const T& value = T(),
                 const Allocator& alloc = Allocator());

	- https://stackoverflow.com/questions/45847787/how-to-differentiate-fill-constructor-and-range-constructor-in-c11
	- https://stackoverflow.com/questions/21042872/how-to-implement-fill-constructor-and-range-constructor-for-sequence-containers

	- SFINAE
		https://en.cppreference.com/w/cpp/language/sfinae

	- Tag dispatching
		https://en.cppreference.com/w/cpp/iterator/iterator_tags#Example

	- Check iterator category (LLVM):
		https://github.com/llvm-mirror/libcxx/blob/24047fd4a7e8231b2220abc1d20b16bc5de3ee87/include/iterator#L512

	- https://stackoverflow.com/questions/38981588/why-give-a-typename-template-parameter-a-default-value-of-0-in-c


1.11	Resize
	- when std::bad_alloc or std::length_error
		array is already null
		size == capacity == 0

	- bad_alloc
		https://en.cppreference.com/w/cpp/memory/new/bad_alloc

	- length_error
		https://www.cplusplus.com/reference/stdexcept/length_error/
		https://en.cppreference.com/w/cpp/error/length_error

	- max_size()
		https://en.cppreference.com/w/cpp/container/vector/max_size


1.12	Insert
	- single
		position in [begin, end], otherwise undefined behavior or segfault 

	- data may be copied into allocated memory without construct





X.	vector<bool>:
		https://en.cppreference.com/w/cpp/container/vector_bool



		*** 2. Stack ***



		*** 3. Map ***



